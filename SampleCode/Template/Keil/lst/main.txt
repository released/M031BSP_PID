; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.GetTick||, CODE, READONLY, ALIGN=2

                  GetTick PROC
;;;50     
;;;51     uint32_t GetTick(void)
000000  4801              LDR      r0,|L1.8|
;;;52     {
;;;53     	return uwTick;
000002  6880              LDR      r0,[r0,#8]  ; uwTick
;;;54     }
000004  4770              BX       lr
;;;55     
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      ||.data||

                          AREA ||i.IncTick_1msIRQ||, CODE, READONLY, ALIGN=2

                  IncTick_1msIRQ PROC
;;;45     
;;;46     void IncTick_1msIRQ(void)	// 1 ms timer interrupt
000000  4802              LDR      r0,|L2.12|
;;;47     {
;;;48     	uwTick++;
000002  6881              LDR      r1,[r0,#8]  ; uwTick
000004  1c49              ADDS     r1,r1,#1
000006  6081              STR      r1,[r0,#8]  ; uwTick
;;;49     }
000008  4770              BX       lr
;;;50     
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      ||.data||

                          AREA ||i.PID_calculate||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  PID_calculate PROC
;;;146    
;;;147    void PID_calculate(float target)
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;148    {
000002  b082              SUB      sp,sp,#8
;;;149    
;;;150        int cnt = 0;
000004  2500              MOVS     r5,#0
;;;151      	__IO int speed = 0;
;;;152    
;;;153    	static uint16_t current = 0;
;;;154    	static uint16_t previous = 0;
;;;155    
;;;156    	uint16_t convergence = 0;
;;;157    
;;;158    	if (previous == (uint16_t)target)
000006  9501              STR      r5,[sp,#4]
000008  9802              LDR      r0,[sp,#8]
00000a  f7fffffe          BL       __aeabi_f2uiz
00000e  4e18              LDR      r6,|L3.112|
000010  4607              MOV      r7,r0
000012  8871              LDRH     r1,[r6,#2]  ; previous
000014  b280              UXTH     r0,r0
000016  4288              CMP      r0,r1
000018  d029              BEQ      |L3.110|
;;;159    	{
;;;160    //		printf("target same last data , skip flow\r\n");
;;;161    		return;
;;;162    	}
;;;163    
;;;164    	current = (uint16_t)target;
00001a  8030              STRH     r0,[r6,#0]
;;;165    	convergence = current % 10;
00001c  210a              MOVS     r1,#0xa
00001e  f7fffffe          BL       __aeabi_uidivmod
000022  460c              MOV      r4,r1
                  |L3.36|
;;;166    	
;;;167    	while(1)
;;;168        {
;;;169    		speed = (uint16_t) PID_realize(target);
000024  9802              LDR      r0,[sp,#8]
000026  f7fffffe          BL       PID_realize
00002a  f7fffffe          BL       __aeabi_f2uiz
00002e  b280              UXTH     r0,r0
;;;170    //		printf("speed : %3d (target : %3d)\n",(int)speed,(int)target);
;;;171    
;;;172    		if (((current - previous) <= convergence) || ((previous - current) <= convergence))
000030  9001              STR      r0,[sp,#4]
000032  8830              LDRH     r0,[r6,#0]  ; current
000034  8871              LDRH     r1,[r6,#2]  ; previous
000036  1a42              SUBS     r2,r0,r1
000038  42a2              CMP      r2,r4
00003a  dd02              BLE      |L3.66|
00003c  1a09              SUBS     r1,r1,r0
00003e  42a1              CMP      r1,r4
000040  dc00              BGT      |L3.68|
                  |L3.66|
000042  1c6d              ADDS     r5,r5,#1
                  |L3.68|
;;;173    		{
;;;174    			#if defined (PID_LOG_APPROACH_PROCESS)
;;;175    			printf("cnt : %3d , speed : %3d (target : %3d)\r\n" ,cnt,(uint16_t)speed,(uint16_t)target);
;;;176    			#endif
;;;177    			cnt++;
;;;178    		}
;;;179    
;;;180    		if (((speed+1) == current) || (speed == current))
000044  9901              LDR      r1,[sp,#4]
000046  1c49              ADDS     r1,r1,#1
000048  4281              CMP      r1,r0
00004a  d002              BEQ      |L3.82|
00004c  9901              LDR      r1,[sp,#4]
00004e  4281              CMP      r1,r0
000050  d1e8              BNE      |L3.36|
                  |L3.82|
000052  68b1              LDR      r1,[r6,#8]  ; uwTick
;;;181    		{   			
;;;182    			#if defined (PID_LOG_RESULT_SPEND_TIME)
;;;183    //			printf("cnt : %3d , speed : %3d (target : %3d)\r\n" ,cnt,(uint16_t)speed,(uint16_t)target);
;;;184    
;;;185    			#if defined (USE_TIMER_CALCULATE_TIMING)
;;;186    			printf("cnt : %3d , time : %5d us , speed : %5d (target : %5d)\r\n" ,cnt,GetTick() - tickstart,(uint16_t)speed,(uint16_t)target);
000054  b2b8              UXTH     r0,r7
000056  68f2              LDR      r2,[r6,#0xc]  ; tickstart
000058  9000              STR      r0,[sp,#0]
00005a  1a8a              SUBS     r2,r1,r2
00005c  4629              MOV      r1,r5
00005e  a005              ADR      r0,|L3.116|
000060  9b01              LDR      r3,[sp,#4]
000062  f7fffffe          BL       __2printf
;;;187    			#endif
;;;188    				
;;;189    			#endif
;;;190    			cnt = 0;				
;;;191    			break;
;;;192    		}		
;;;193        }
;;;194    
;;;195    	previous = (int)target;
000066  9802              LDR      r0,[sp,#8]
000068  f7fffffe          BL       __aeabi_f2iz
00006c  8070              STRH     r0,[r6,#2]
                  |L3.110|
;;;196    	
;;;197    }
00006e  bdfe              POP      {r1-r7,pc}
;;;198    
                          ENDP

                  |L3.112|
                          DCD      ||.data||
                  |L3.116|
000074  636e7420          DCB      "cnt : %3d , time : %5d us , speed : %5d (target : %5d)\r"
000078  3a202533
00007c  64202c20
000080  74696d65
000084  203a2025
000088  35642075
00008c  73202c20
000090  73706565
000094  64203a20
000098  25356420
00009c  28746172
0000a0  67657420
0000a4  3a202535
0000a8  64290d  
0000ab  0a00              DCB      "\n",0
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.PID_init||, CODE, READONLY, ALIGN=2

                  PID_init PROC
;;;56     
;;;57     void PID_init(float Kp , float Ki , float Kd)
000000  b510              PUSH     {r4,lr}
;;;58     {
;;;59         pid.SetSpeed = 0.0;
000002  4b04              LDR      r3,|L4.20|
000004  2400              MOVS     r4,#0
;;;60         pid.ActualSpeed = 0.0;
000006  601c              STR      r4,[r3,#0]  ; pid
;;;61         pid.err = 0.0;
000008  605c              STR      r4,[r3,#4]  ; pid
;;;62         pid.err_last = 0.0;
00000a  609c              STR      r4,[r3,#8]  ; pid
00000c  60dc              STR      r4,[r3,#0xc]  ; pid
00000e  3310              ADDS     r3,r3,#0x10
000010  c317              STM      r3!,{r0-r2,r4}
;;;63     	pid.Kp = Kp;
;;;64     	pid.Ki = Ki;
;;;65     	pid.Kd = Kd;	
;;;66     
;;;67     	#if defined (PID_INCREMENTAL)	
;;;68     	pid.err_next = 0.0;
;;;69     	#endif 
;;;70     
;;;71     	#if defined (PID_ANTI_WINDUP)	
;;;72     	pid.voltage = 0.0;
;;;73     	pid.integral = 0.0;
;;;74     	pid.umax = 400;
;;;75     	pid.umin =-200; 
;;;76     	#endif 
;;;77     }
000012  bd10              POP      {r4,pc}
;;;78     
                          ENDP

                  |L4.20|
                          DCD      ||.bss||

                          AREA ||i.PID_realize||, CODE, READONLY, ALIGN=2

                  PID_realize PROC
;;;78     
;;;79     float PID_realize(float speed)
000000  b5fe              PUSH     {r1-r7,lr}
;;;80     {
;;;81     	float incrementSpeed;
;;;82     
;;;83     	pid.SetSpeed=speed;
000002  4c18              LDR      r4,|L5.100|
;;;84     	pid.err=pid.SetSpeed-pid.ActualSpeed;
000004  6020              STR      r0,[r4,#0]  ; pid
000006  6861              LDR      r1,[r4,#4]  ; pid
000008  9100              STR      r1,[sp,#0]
00000a  f7fffffe          BL       __aeabi_fsub
;;;85     
;;;86     	#if defined (PID_INCREMENTAL)
;;;87     
;;;88         incrementSpeed = pid.Kp*(pid.err-pid.err_next) + pid.Ki*pid.err + pid.Kd*(pid.err - 2*pid.err_next + pid.err_last);
00000e  60a0              STR      r0,[r4,#8]  ; pid
000010  69e5              LDR      r5,[r4,#0x1c]  ; pid
000012  4606              MOV      r6,r0                 ;84
000014  2101              MOVS     r1,#1
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       __ARM_scalbnf
00001c  4631              MOV      r1,r6
00001e  f7fffffe          BL       __aeabi_frsub
000022  68e1              LDR      r1,[r4,#0xc]  ; pid
000024  f7fffffe          BL       __aeabi_fadd
000028  69a1              LDR      r1,[r4,#0x18]  ; pid
00002a  f7fffffe          BL       __aeabi_fmul
00002e  4607              MOV      r7,r0
000030  4631              MOV      r1,r6
000032  6960              LDR      r0,[r4,#0x14]  ; pid
000034  f7fffffe          BL       __aeabi_fmul
000038  9001              STR      r0,[sp,#4]
00003a  4629              MOV      r1,r5
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       __aeabi_fsub
000042  6921              LDR      r1,[r4,#0x10]  ; pid
000044  f7fffffe          BL       __aeabi_fmul
000048  9901              LDR      r1,[sp,#4]
00004a  f7fffffe          BL       __aeabi_fadd
00004e  4639              MOV      r1,r7
000050  f7fffffe          BL       __aeabi_fadd
000054  4601              MOV      r1,r0
;;;89         pid.ActualSpeed += incrementSpeed;
000056  9800              LDR      r0,[sp,#0]
000058  f7fffffe          BL       __aeabi_fadd
;;;90         pid.err_last = pid.err_next;
;;;91         pid.err_next = pid.err;
00005c  61e6              STR      r6,[r4,#0x1c]  ; pid
00005e  60e5              STR      r5,[r4,#0xc]  ; pid
000060  6060              STR      r0,[r4,#4]  ; pid
;;;92     	#endif
;;;93     
;;;94     	#if defined (PID_ANTI_WINDUP)
;;;95     	int index;	
;;;96     	if (pid.ActualSpeed>pid.umax)
;;;97     	{
;;;98     		if(abs(pid.err)>200)
;;;99     		{
;;;100    			index=0;
;;;101    		}
;;;102    		else
;;;103    		{
;;;104    			index=1;
;;;105    			if(pid.err<0)
;;;106    			{
;;;107    				pid.integral+=pid.err;
;;;108    			}
;;;109    		}
;;;110    	}
;;;111    	else if (pid.ActualSpeed<pid.umin)
;;;112    	{
;;;113    		if(abs(pid.err)>200)
;;;114    		{
;;;115    			index=0;
;;;116    		}
;;;117    		else
;;;118    		{
;;;119    			index=1;
;;;120    			if(pid.err>0)
;;;121    			{
;;;122    				pid.integral+=pid.err;
;;;123    			}
;;;124    		}
;;;125    	}
;;;126    	else
;;;127    	{
;;;128    		if(abs(pid.err)>200)
;;;129    		{
;;;130    			index=0;
;;;131    		}
;;;132    		else
;;;133    		{
;;;134    			index=1;
;;;135    			pid.integral+=pid.err;
;;;136    		}
;;;137    	}
;;;138    	
;;;139    	pid.voltage=pid.Kp*pid.err+index*pid.Ki*pid.integral+pid.Kd*(pid.err-pid.err_last);
;;;140    	pid.err_last=pid.err;
;;;141    	pid.ActualSpeed=pid.voltage*1.0;
;;;142    	#endif
;;;143    	
;;;144    	return pid.ActualSpeed;
;;;145    }
000062  bdfe              POP      {r1-r7,pc}
;;;146    
                          ENDP

                  |L5.100|
                          DCD      ||.bss||

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;247    
;;;248    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  4c1a              LDR      r4,|L6.112|
000006  2216              MOVS     r2,#0x16
000008  2188              MOVS     r1,#0x88
                  |L6.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6022              STR      r2,[r4,#0]
00000e  6021              STR      r1,[r4,#0]
000010  6823              LDR      r3,[r4,#0]
000012  2b00              CMP      r3,#0
000014  d0f9              BEQ      |L6.10|
;;;249    {
;;;250        /* Unlock protected registers */
;;;251        SYS_UnlockReg();
;;;252    
;;;253        /* Enable HIRC clock (Internal RC 48MHz) */
;;;254        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;255    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;256    	
;;;257        /* Wait for HIRC clock ready */
;;;258        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;259    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;260    	
;;;261        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;262        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000022  2100              MOVS     r1,#0
000024  2007              MOVS     r0,#7
000026  f7fffffe          BL       CLK_SetHCLK
;;;263    
;;;264        /* Enable UART0 clock */
;;;265        CLK_EnableModuleClock(UART0_MODULE);
00002a  4d12              LDR      r5,|L6.116|
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       CLK_EnableModuleClock
;;;266        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
000032  2101              MOVS     r1,#1
000034  2200              MOVS     r2,#0
000036  0689              LSLS     r1,r1,#26
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       CLK_SetModuleClock
;;;267    	
;;;268        CLK_EnableModuleClock(TMR3_MODULE);
00003e  4d0e              LDR      r5,|L6.120|
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       CLK_EnableModuleClock
;;;269        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
000046  2101              MOVS     r1,#1
000048  2200              MOVS     r2,#0
00004a  0549              LSLS     r1,r1,#21
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       CLK_SetModuleClock
;;;270    	
;;;271        /* Update System Core Clock */
;;;272        SystemCoreClockUpdate();
000052  f7fffffe          BL       SystemCoreClockUpdate
;;;273    
;;;274        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;275        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
000056  07a8              LSLS     r0,r5,#30
000058  6bc1              LDR      r1,[r0,#0x3c]
00005a  22ff              MOVS     r2,#0xff
00005c  0412              LSLS     r2,r2,#16
00005e  4391              BICS     r1,r1,r2
000060  2233              MOVS     r2,#0x33
000062  0452              LSLS     r2,r2,#17
000064  1889              ADDS     r1,r1,r2
000066  63c1              STR      r1,[r0,#0x3c]
000068  2000              MOVS     r0,#0
00006a  6020              STR      r0,[r4,#0]
;;;276                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;277    
;;;278        /* Lock protected registers */
;;;279        SYS_LockReg();
;;;280    }
00006c  bd70              POP      {r4-r6,pc}
;;;281    
                          ENDP

00006e  0000              DCW      0x0000
                  |L6.112|
                          DCD      0x40000100
                  |L6.116|
                          DCD      0x5f803d10
                  |L6.120|
                          DCD      0x5f400005

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;221    
;;;222    void TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;223    {
;;;224        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L7.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1488              ASRS     r0,r1,#18
00001c  4904              LDR      r1,|L7.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;225        TIMER_EnableInt(TIMER3);
;;;226        NVIC_EnableIRQ(TMR3_IRQn);	
;;;227        TIMER_Start(TIMER3);
;;;228    }
000028  bd10              POP      {r4,pc}
;;;229    
                          ENDP

00002a  0000              DCW      0x0000
                  |L7.44|
                          DCD      0x40051020
                  |L7.48|
                          DCD      0xe000e100

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR3_IRQHandler PROC
;;;198    
;;;199    void TMR3_IRQHandler(void)
000000  b500              PUSH     {lr}
000002  490a              LDR      r1,|L8.44|
000004  6888              LDR      r0,[r1,#8]
000006  07c0              LSLS     r0,r0,#31
000008  0fc0              LSRS     r0,r0,#31
;;;200    {
00000a  d00d              BEQ      |L8.40|
00000c  2001              MOVS     r0,#1
00000e  6088              STR      r0,[r1,#8]
;;;201    	static uint32_t LOG = 0;
;;;202    	static uint16_t CNT = 0;
;;;203    	
;;;204        if(TIMER_GetIntFlag(TIMER3) == 1)
;;;205        {
;;;206            TIMER_ClearIntFlag(TIMER3);
;;;207    
;;;208    		#if defined (USE_TIMER_CALCULATE_TIMING)
;;;209    		IncTick_1msIRQ();
000010  f7fffffe          BL       IncTick_1msIRQ
;;;210    		#endif
;;;211    		
;;;212    		if (CNT++ >= 1000)
000014  4906              LDR      r1,|L8.48|
000016  8888              LDRH     r0,[r1,#4]  ; CNT
000018  1c42              ADDS     r2,r0,#1
00001a  808a              STRH     r2,[r1,#4]
00001c  227d              MOVS     r2,#0x7d
00001e  00d2              LSLS     r2,r2,#3
000020  4290              CMP      r0,r2
000022  d301              BCC      |L8.40|
;;;213    		{		
;;;214    			CNT = 0;
000024  2000              MOVS     r0,#0
000026  8088              STRH     r0,[r1,#4]
                  |L8.40|
;;;215    //        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;216    		}
;;;217    		
;;;218        }
;;;219    }
000028  bd00              POP      {pc}
;;;220    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40051020
                  |L8.48|
                          DCD      ||.data||

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;230    
;;;231    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;232    {
;;;233        SYS_ResetModule(UART0_RST);
000002  4813              LDR      r0,|L9.80|
000004  f7fffffe          BL       SYS_ResetModule
;;;234    
;;;235        /* Configure UART0 and set UART0 baud rate */
;;;236        UART_Open(UART0, 115200);
000008  21e1              MOVS     r1,#0xe1
00000a  0249              LSLS     r1,r1,#9
00000c  4811              LDR      r0,|L9.84|
00000e  f7fffffe          BL       UART_Open
;;;237    
;;;238    	/* Set UART receive time-out */
;;;239    //	UART_SetTimeoutCnt(UART0, 20);
;;;240    
;;;241    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000012  f7fffffe          BL       CLK_GetCPUFreq
000016  4601              MOV      r1,r0
000018  a00f              ADR      r0,|L9.88|
00001a  f7fffffe          BL       __2printf
;;;242    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
00001e  f7fffffe          BL       CLK_GetHXTFreq
000022  4601              MOV      r1,r0
000024  a013              ADR      r0,|L9.116|
000026  f7fffffe          BL       __2printf
;;;243    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
00002a  f7fffffe          BL       CLK_GetLXTFreq
00002e  4601              MOV      r1,r0
000030  a016              ADR      r0,|L9.140|
000032  f7fffffe          BL       __2printf
;;;244    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000036  f7fffffe          BL       CLK_GetPCLK0Freq
00003a  4601              MOV      r1,r0
00003c  a019              ADR      r0,|L9.164|
00003e  f7fffffe          BL       __2printf
;;;245    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
000042  f7fffffe          BL       CLK_GetPCLK1Freq
000046  4601              MOV      r1,r0
000048  a01d              ADR      r0,|L9.192|
00004a  f7fffffe          BL       __2printf
;;;246    }
00004e  bd10              POP      {r4,pc}
;;;247    
                          ENDP

                  |L9.80|
                          DCD      0x04000010
                  |L9.84|
                          DCD      0x40070000
                  |L9.88|
000058  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
00005c  4b5f4765
000060  74435055
000064  46726571
000068  203a2025
00006c  38640d0a
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0
                  |L9.116|
000074  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
000078  47657448
00007c  58544672
000080  6571203a
000084  20253864
000088  0d0a00  
00008b  00                DCB      0
                  |L9.140|
00008c  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
000090  4765744c
000094  58544672
000098  6571203a
00009c  20253864
0000a0  0d0a00  
0000a3  00                DCB      0
                  |L9.164|
0000a4  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000a8  47657450
0000ac  434c4b30
0000b0  46726571
0000b4  203a2025
0000b8  38640d0a
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L9.192|
0000c0  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000c4  47657450
0000c8  434c4b31
0000cc  46726571
0000d0  203a2025
0000d4  38640d0a
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;289    
;;;290    int main()
000000  f7fffffe          BL       SYS_Init
;;;291    {
;;;292      	uint16_t data = 0;	
;;;293    
;;;294        SYS_Init();
;;;295    
;;;296        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;297    
;;;298    	TIMER3_Init();
000008  f7fffffe          BL       TIMER3_Init
;;;299    
;;;300    	#if defined (USE_RANDOM_SEED_GENERATE_DATA)
;;;301    	srand(0x1234);	//seed
00000c  480b              LDR      r0,|L10.60|
00000e  f7fffffe          BL       srand
;;;302    	#endif
;;;303    
;;;304    	PID_init(0.2 , 0.015 , 0.2);
000012  480b              LDR      r0,|L10.64|
000014  490b              LDR      r1,|L10.68|
000016  4602              MOV      r2,r0
000018  f7fffffe          BL       PID_init
00001c  4c0a              LDR      r4,|L10.72|
;;;305    	
;;;306        /* Got no where to go, just loop forever */
;;;307        while(1)
;;;308        {
;;;309    
;;;310    		#if defined (USE_TIMER_CALCULATE_TIMING)
;;;311    		// use timer to calculate each PID approach process spend time
;;;312    		tickstart = GetTick();
;;;313    		#endif
;;;314    
;;;315    		#if defined (USE_RANDOM_SEED_GENERATE_DATA)
;;;316    		data = rand()%(0xFFFF-1) + 1;	//0xFF	
00001e  4d0b              LDR      r5,|L10.76|
                  |L10.32|
000020  68a0              LDR      r0,[r4,#8]  ; uwTick
000022  60e0              STR      r0,[r4,#0xc]  ; tickstart
000024  f7fffffe          BL       rand
000028  4629              MOV      r1,r5
00002a  f7fffffe          BL       __aeabi_idivmod
00002e  1c49              ADDS     r1,r1,#1
000030  b288              UXTH     r0,r1
;;;317    		#endif
;;;318    
;;;319    		// send random data to use PID flow , to approach to data 
;;;320    		PID_calculate(data);
000032  f7fffffe          BL       __aeabi_ui2f
000036  f7fffffe          BL       PID_calculate
00003a  e7f1              B        |L10.32|
;;;321        }
;;;322    }
;;;323    
                          ENDP

                  |L10.60|
                          DCD      0x00001234
                  |L10.64|
                          DCD      0x3e4ccccd
                  |L10.68|
                          DCD      0x3c75c28f
                  |L10.72|
                          DCD      ||.data||
                  |L10.76|
                          DCD      0x0000fffe

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pid
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  current
000000  0000              DCW      0x0000
                  previous
000002  0000              DCW      0x0000
                  ||CNT||
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  uwTick
                          DCD      0x00000000
                  tickstart
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_uwTick____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_uwTick____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_uwTick____REVSH|
#line 402
|__asm___6_main_c_uwTick____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
